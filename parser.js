var fs = require('fs');
var csvParse = require('fast-csv');
var mongojs = require('mongojs');
var helpers = require('./helpers.js');
var settings = require('./settings.json');

// Holds csv parsed data
var parsedData = [];
// TO identify header row inside csvParse callback
// Note* fast-csv doesn't provide index
var isHeaderRow = true;
// Holds all the valid params/arguments by user ref. settinfs.json -> options
var options;

var query = {
  // Converts csv row to object with headers as key
  // Each cell value in the row will be deStringified
  'convertToJSON': function () {
    parsedData = parsedData.map(data => {
      let obj = {};
      options.headers.forEach((header, i) => {
        // If a cell does not have any value or invalid value then
        // by default empty string ('') will be assigned
        // if changing then ref. deStringify
        obj[header] = data[i] ? helpers.deStringify(data[i]) : '';
      });

      return obj;
    });
  },

  // Inserts each record to specified DB -> collection
  // each csv tuple will be converted to JSON before insertion
  'insertToCollection': function () {
    let totalRecords = parsedData.length;
    let { collection, databaseUrl } = options;
    let db = mongojs(databaseUrl, [collection]);
    let insertCount = 0;
    let timeStamp = new Date().getTime();

    this.convertToJSON();

    for (let i = 0; i < parsedData.length; i++) {
      // Adding few optional fields for better query in DB
      // can be modified
      // cAt - createdAt, mAt - modifiedAt, rType - recordType
      parsedData[i]['cAt'] = timeStamp;
      parsedData[i]['mAt'] = timeStamp;
      parsedData[i]['rType'] = 'Parsed';

      // Hance not using promise for insert
      // because no nesting callbacks / no asyc opertion performed inside callback
      // Can be updated to promise if callback purpose changes
      db[collection].insert(parsedData[i], function (error) {
        if (error) console.log(error);

        if (totalRecords === ++insertCount) {
          db.close();
          console.log(`Total ${insertCount} parsed records are updated to the collection "${collection}" \n`);
        }
      });
    }
  },

  saveToJSON: function () {
    let { saveToDir } = settings;
    let dir = __dirname + saveToDir;

    // Extracting file name. eg. files/social/facebook.csv => facebook.csv
    let file = options.file.split('/').pop();
    let now = new Date();
    let formattedTime = `${now.getHours()}h${now.getMinutes()}m${now.getSeconds()}s`;
    let formattedDate = `${now.getDate()}-${now.getMonth()}-${now.getFullYear()}-${formattedTime}`;

    // Unique path will be generated by file and Data literals
    // eg. facebook-16-08-2017-18h47m22s.json
    let path = `${dir}${file.split('.').shift()}-${formattedDate}.json`;

    // indent - only to creted human readable JSON file
    // No indent - result will be saved in single line, later it can be formatted according to editor's JSON standard
    let indent = settings.JSONStringifyIndent;

    // Converting to JSON format
    this.convertToJSON();

    // If directory does not exists!
    // then create the directory by specified directory name ref. saveToDir at settings.json
    if (dir && !fs.existsSync(dir)) {
      fs.mkdirSync(dir);
    }

    // Hance parsedData is a Array of Objects so, stringifing as object litererals. ref. JSON standars
    fs.writeFile(path, JSON.stringify({"JSONData": parsedData}, null, indent), function (err) {
      if (err) return console.log(err);
      console.log(`File successfully saved to ${path}`);
    });
  },

// To sort parsedData by keyIndex
  sort: function () {
    let { keyIndex } = options;
    parsedData = parsedData.sort((a, b) => {
      return (a[keyIndex].toLowerCase() > b[keyIndex].toLowerCase() && 1) ||
        (a[keyIndex].toLowerCase() > b[keyIndex].toLowerCase() && -1) || 0;
    });
  }
};


// Checks for duplicate record in parsedData by keyIndex
function notDuplicate (value) {
  return !parsedData.some(data => { return data[options.keyIndex] === value; });
}

options = helpers.getOptions();
// Check for file(csv) existance
helpers.checkFile(options.file);

console.log('Parsing Initiated....');

csvParse.fromPath(options.file, {
  headers: false,
  trim: true,
  ignoreEmpty: true
}).on('data', function (row) {

  // To skip header
  if (options.skipHeader === 'Y') {
    isHeaderRow = false;
    return;
  }

  // First row of the document is tobe considered as header row
  // if headers has invalid value like undefined or null then they are ignored
  if (options.hasHeaders === 'Y' && isHeaderRow) {
    options.headers = [];
    row.forEach(header => { if (header) options.headers.push(header.toCamelCase()); });
    isHeaderRow = false;
    return;
  }

  if (options.removeDuplicate === 'Y') {
    if (notDuplicate(row[options.keyIndex])) parsedData.push(row);
    return;
  }

  parsedData.push(row);
}).on('end', function () {
  console.log('Parsing Completed.');
  console.log('Processing next step...');

  if (options.sort === 'Y') query.sort();

  // Calling specified query function...
  query[options.method]();
});
